const express = require('express');
const cors = require('cors');
const axios = require('axios');
const { z } = require('zod');
const fs = require('fs');
const path = require('path');
const os = require('os');

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());

// Validation schemas using Zod
const JiraConfigSchema = z.object({
  jiraUrl: z.string()
    .url({ message: "Please enter a valid URL" })
    .refine(url => url.includes('atlassian.net') || url.includes('jira'), {
      message: "Please enter a valid Jira URL (should contain 'atlassian.net' or 'jira')"
    }),
  username: z.string()
    .min(1, { message: "Username is required" })
    .email({ message: "Please enter a valid email address" }),
  apiToken: z.string()
    .min(10, { message: "API Token must be at least 10 characters long" }),
  projectKey: z.string()
    .optional()
    .refine(val => !val || /^[A-Z][A-Z0-9]*$/.test(val), {
      message: "Project key must start with a letter and contain only uppercase letters and numbers"
    })
});

// Helper function to get config file path
const getConfigPath = () => {
  return path.join(os.homedir(), '.jira-mcp.env');
};

// Helper function to test Jira connection
const testJiraConnection = async (jiraUrl, username, apiToken) => {
  try {
    const authBuffer = Buffer.from(`${username}:${apiToken}`).toString('base64');
    
    const response = await axios.get(`${jiraUrl}/rest/api/2/myself`, {
      headers: {
        Authorization: `Basic ${authBuffer}`,
        Accept: 'application/json'
      },
      timeout: 10000
    });

    return {
      success: true,
      message: `Successfully connected to Jira as ${response.data.displayName}`,
      userInfo: {
        displayName: response.data.displayName,
        emailAddress: response.data.emailAddress,
        accountId: response.data.accountId
      }
    };
  } catch (error) {
    let errorMessage = 'Connection failed';
    
    if (error.code === 'ENOTFOUND') {
      errorMessage = 'Invalid Jira URL - domain not found';
    } else if (error.response?.status === 401) {
      errorMessage = 'Invalid credentials - please check your username and API token';
    } else if (error.response?.status === 403) {
      errorMessage = 'Access forbidden - please check your permissions';
    } else if (error.code === 'ECONNABORTED') {
      errorMessage = 'Connection timeout - please check your Jira URL';
    } else if (error.message) {
      errorMessage = `Connection error: ${error.message}`;
    }

    return {
      success: false,
      message: errorMessage
    };
  }
};

// API Routes

// Test Jira connection
app.post('/api/test-connection', async (req, res) => {
  try {
    const validatedData = JiraConfigSchema.parse(req.body);
    
    const result = await testJiraConnection(
      validatedData.jiraUrl,
      validatedData.username,
      validatedData.apiToken
    );
    
    res.json(result);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message
        }))
      });
    }
    
    res.status(500).json({
      success: false,
      message: 'Server error during connection test'
    });
  }
});

// Save configuration
app.post('/api/save-config', async (req, res) => {
  try {
    const validatedData = JiraConfigSchema.parse(req.body);
    
    // Test connection first
    const connectionResult = await testJiraConnection(
      validatedData.jiraUrl,
      validatedData.username,
      validatedData.apiToken
    );
    
    if (!connectionResult.success) {
      return res.status(400).json({
        success: false,
        message: 'Cannot save configuration - connection test failed',
        connectionError: connectionResult.message
      });
    }
    
    // Create .env content
    const envContent = [
      `JIRA_URL=${validatedData.jiraUrl}`,
      `JIRA_USERNAME=${validatedData.username}`,
      `JIRA_API_TOKEN=${validatedData.apiToken}`,
      validatedData.projectKey ? `JIRA_PROJECT_KEY=${validatedData.projectKey}` : '',
      '# Configuration generated by Jira MCP Config UI',
      `# Generated on: ${new Date().toISOString()}`
    ].filter(line => line.length > 0).join('\n');
    
    // Save to file
    const configPath = getConfigPath();
    fs.writeFileSync(configPath, envContent, 'utf8');
    
    res.json({
      success: true,
      message: 'Configuration saved successfully!',
      configPath,
      userInfo: connectionResult.userInfo
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message
        }))
      });
    }
    
    console.error('Error saving config:', error);
    res.status(500).json({
      success: false,
      message: 'Server error while saving configuration'
    });
  }
});

// Load existing configuration
app.get('/api/load-config', (req, res) => {
  try {
    const configPath = getConfigPath();
    
    if (!fs.existsSync(configPath)) {
      return res.json({
        success: true,
        config: null,
        message: 'No existing configuration found'
      });
    }
    
    const envContent = fs.readFileSync(configPath, 'utf8');
    const config = {};
    
    envContent.split('\n').forEach(line => {
      if (line.startsWith('JIRA_URL=')) {
        config.jiraUrl = line.split('=', 2)[1];
      } else if (line.startsWith('JIRA_USERNAME=')) {
        config.username = line.split('=', 2)[1];
      } else if (line.startsWith('JIRA_API_TOKEN=')) {
        // Mask the API token for security
        const token = line.split('=', 2)[1];
        config.apiToken = token ? `${'*'.repeat(Math.max(0, token.length - 4))}${token.slice(-4)}` : '';
        config.hasApiToken = !!token;
      } else if (line.startsWith('JIRA_PROJECT_KEY=')) {
        config.projectKey = line.split('=', 2)[1];
      }
    });
    
    res.json({
      success: true,
      config,
      configPath
    });
  } catch (error) {
    console.error('Error loading config:', error);
    res.status(500).json({
      success: false,
      message: 'Error loading existing configuration'
    });
  }
});

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('Unhandled error:', error);
  res.status(500).json({
    success: false,
    message: 'Internal server error'
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`ğŸš€ Jira MCP Configuration Server running on http://localhost:${PORT}`);
  console.log(`ğŸ“ Config file location: ${getConfigPath()}`);
});